<!doctype html>
<html lang="en-US" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title></title>
        <link rel="stylesheet" href="../../code-examples.css" />
    </head>
    <body>
    <!-- Markup generated by vim-screenshot -->
<table cellspacing=0 cellpadding=0  style="color:#d7d7d7;background:#121212" ><tr><td><pre><font color=#d7d7d7><font color=#d7afff>filter</font>(<font color=#d7afff>function</font>, <font color=#d7afff>list</font>) { 
    filtered-list = (); 
 
    for element in list { 
        if (function(element)) { 
            push(filtered-list, element); 
        } 
    } 
 
    return filtered-list; 
} 
 
<font color=#808080>/*</font> 
<font color=#808080>Some would say this is not a true quicksort, and they might be right. The</font> 
<font color=#808080>implementation could easily be adjusted to partition elements in place, but then</font> 
<font color=#808080>we wouldn't be using higher-order functions.</font> 
 
<font color=#808080>There's a great discussion about this on Stack Overflow:</font> 
<font color=#808080>https://stackoverflow.com/questions/7717691/why-is-the-minimalist-example-haskell-quicksort-not-a-true-quicksort</font> 
<font color=#808080>*/</font> 
<font color=#d7afff>quicksort</font>(list) { 
    if (length(list) == 0) { 
        return (); 
    } 
 
    pivot = list[0]; 
    sorted = (); 
 
    /* Build a list that contains everything except for the pivot */ 
    remaining = (); 
    i = 0; 
    for element in list { 
        if (i != 0) { 
            push(remaining, element); 
        } 
        i = i + 1; 
    } 
 
    smaller-sorted = quicksort(filter(@(num) { 
        return num &lt;= pivot; 
    }, remaining)); 
 
    bigger-sorted = quicksort(filter(@(num) { 
        return num &gt; pivot; 
    }, remaining)); 
 
    push(sorted, smaller-sorted, pivot, bigger-sorted); 
 
    return sorted; 
} 
 
<font color=#87af5f>#</font><font color=#d7afff>out</font> { 
    sorted-numbers: quicksort((5 93 6 13 72 45 7 82 9 63 2)); 
}</pre>
    </body>
</html>
